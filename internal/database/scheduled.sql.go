// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: scheduled.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createScheduledWebhook = `-- name: CreateScheduledWebhook :exec
INSERT INTO scheduled_webhooks (
    id, subscription_id, payload, scheduled_for, recurrence, status
) VALUES (
    ?, ?, ?, ?, ?, 'pending'
)
`

type CreateScheduledWebhookParams struct {
	ID             string
	SubscriptionID string
	Payload        string
	ScheduledFor   time.Time
	Recurrence     sql.NullString
}

func (q *Queries) CreateScheduledWebhook(ctx context.Context, arg CreateScheduledWebhookParams) error {
	_, err := q.db.ExecContext(ctx, createScheduledWebhook,
		arg.ID,
		arg.SubscriptionID,
		arg.Payload,
		arg.ScheduledFor,
		arg.Recurrence,
	)
	return err
}

const deleteScheduledWebhook = `-- name: DeleteScheduledWebhook :exec
DELETE FROM scheduled_webhooks WHERE id = ?
`

func (q *Queries) DeleteScheduledWebhook(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteScheduledWebhook, id)
	return err
}

const getDueScheduledWebhooks = `-- name: GetDueScheduledWebhooks :many
SELECT id, subscription_id, payload, scheduled_for, recurrence, status, created_at, updated_at FROM scheduled_webhooks
WHERE scheduled_for <= ? AND status = 'pending'
`

func (q *Queries) GetDueScheduledWebhooks(ctx context.Context, scheduledFor time.Time) ([]ScheduledWebhook, error) {
	rows, err := q.db.QueryContext(ctx, getDueScheduledWebhooks, scheduledFor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduledWebhook
	for rows.Next() {
		var i ScheduledWebhook
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.Payload,
			&i.ScheduledFor,
			&i.Recurrence,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllScheduledWebhooks = `-- name: ListAllScheduledWebhooks :many
SELECT id, subscription_id, payload, scheduled_for, recurrence, status, created_at, updated_at
FROM scheduled_webhooks
ORDER BY scheduled_for ASC
LIMIT ? OFFSET ?
`

type ListAllScheduledWebhooksParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListAllScheduledWebhooks(ctx context.Context, arg ListAllScheduledWebhooksParams) ([]ScheduledWebhook, error) {
	rows, err := q.db.QueryContext(ctx, listAllScheduledWebhooks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduledWebhook
	for rows.Next() {
		var i ScheduledWebhook
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.Payload,
			&i.ScheduledFor,
			&i.Recurrence,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledWebhooks = `-- name: ListScheduledWebhooks :many
SELECT id, subscription_id, payload, scheduled_for, recurrence, status, created_at, updated_at FROM scheduled_webhooks
WHERE subscription_id = ?
ORDER BY scheduled_for DESC
LIMIT ? OFFSET ?
`

type ListScheduledWebhooksParams struct {
	SubscriptionID string
	Limit          int64
	Offset         int64
}

func (q *Queries) ListScheduledWebhooks(ctx context.Context, arg ListScheduledWebhooksParams) ([]ScheduledWebhook, error) {
	rows, err := q.db.QueryContext(ctx, listScheduledWebhooks, arg.SubscriptionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduledWebhook
	for rows.Next() {
		var i ScheduledWebhook
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.Payload,
			&i.ScheduledFor,
			&i.Recurrence,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScheduledWebhookStatus = `-- name: UpdateScheduledWebhookStatus :exec
UPDATE scheduled_webhooks
SET status = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateScheduledWebhookStatusParams struct {
	Status string
	ID     string
}

func (q *Queries) UpdateScheduledWebhookStatus(ctx context.Context, arg UpdateScheduledWebhookStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateScheduledWebhookStatus, arg.Status, arg.ID)
	return err
}
